Quasi-3D solar cell solver
==========================

- Example: :doc:`CPV Grid Spice Example (IPython Notebook) <../Examples/cpv_grid_spice_example.ipynb>`
- Example: :doc:`CPV Grid Spice Example (Python) <../Examples/cpv_grid_spice_example.py>`

ï»¿The quasi-3D solar cell model included in Solcore uses a SPICE-based electrical network to model the flow of injected current through the solar cell. The plane of the cell is discretized into many elements, each of them representing a small portion of the cell. Depending on the location of the element - exposed to the sunlight or underneath a metal finger - the IV curve of the cell will be the light IV or the dark IV. Each element is linked to their neighbours with resistors, representing the lateral current flow and dependent on the sheet resistance of the cells. This method can be applied to any number of junctions.

This type of formalism is widely used to simulate the performance of solar cells when the effect of a spatial variable needs to be incorporated in the model. This variable can be the design of the front metal grid, in order to minimise the effect of series resistances; the inhomogeneous illumination profile in concentrator devices; the impact of such inhomogeneity on the transport through the tunnel junctions; or the distribution of defects or inhomogeneities. Recently, this formalism was used to model the photoluminescence and the electroluminescence based IV curves of MJ devices, accounting for the limited lateral carrier transport.

Specifically for the modelling and optimization of the front grid of solar cells in order to minimise shading losses and series resistance, there are two packages already available: `PVMOS <https://github.com/IEK-5/PVMOS>`_, developed by B. E. Pieters in C and released as open source, and `Griddler <https://www.pvlighthouse.com.au/cms/simulation-programs/griddler>`_, developed by J. Wong using Matlab and available at PV Lighthouse.

.. image:: quasi3Dimg.png
    :align: center

In-plane discretization
-----------------------

There are two physical regions in the plane: the metal and the aperture. These two are provided to Solcore as a
grey scale image that defines a mapping between pixels and the layers:

* Metal:

    * **White** is a bus bar (value >=80% white)

    * **Gray** is a grid finger (20% white < value < 80% white)

* Aperture:

    * **Black** is an absence of any metal  (value <= 20% white)


`GridPattern` helper objects can be used to generate these images, for example,
::
    # The width of the bus bar in pixels
    bus_px = 10 
    
    # the number and width of the grid fingers in pixels
    fingers_px =  [4, 4, 4, 4, 4, 4] 

    # the edge offset (set to zero if you want metal to go all the way to the edge)
    offset_px = 3 

    # the size of the image in pixels
    nx, ny = 120, 120

    # the physical size of the solar cell in metres
    size = (0.01, 0.01) 

    # Use a grid pattern object to make the metalisation image
    grid = HGridPattern(bus_px, fingers_px, offset_px=offset_px, nx=nx, ny=ny)
    plt.imshow(grid.as_array(), cmap="gray")

The above code generates the image,

.. image:: HGridPattern.png
    :align: center


The resolution of the images, in pixels, will define the in-plane discretization. However, the physical size
of the solar cell needs to be specified to give each pixel dimensions. For
example, 

* the image above is 120px x 120px
* size tuple `size = (0.01, 0.01)`

Therefore, each pixel 1cm / 120 or approximately 83 micrometers. 

Different aspect ratios can be used to reduce the number of elements and improve speed by specifying a different cell size.

Currently only `HGridPattern` exists, but other grids can be generated by subclass the `GridPattern` object and implementing the required methods.

What is the difference between the bus bar and the grid fingers?
----------------------------------------------------------------

The only difference between the bus bar and the grid fingers is how the former is used in the SPICE model. To run a simulation SPICE must attach a voltage source to the metalisation. The bus bar metal defines these locations.

Because of this, the bus will always have the applied potential where as the grid fingers will be at a potential defined by the current flowing through them and the surrounding cells.

Node Size
---------
The minimum total number of nodes where SPICE will need to calculate the
voltages will be :math:`N \times M \times 2 \times Q`

* N and M are the number of pixels in both in-plane directions
* Q the number of junctions, which require 2 nodes each.

To this, the front and back metal contacts could add a maximum of :math:`2(N \times M)` nodes. 

Exploiting symmetries of the problem as well as choosing an appropriate pixel
aspect ratio will significantly reduce the number of nodes and therefore
the time required for the computation of the problem.


Illumination Map
----------------

The spatial distribution of illumination over the solar cell surface can be included in the simulation using an illumination map array.

This is an numpy array with the same dimensions as the grid pattern. For example,
::

    # Homogeneous illumination
    illumination_map = np.ones(nx * ny).reshape((nx, ny))

following on from the previous code example, this will construct an array of size 120x120. The illumination is homogeneous because all elements in the array have the same value. To change the spatial distribution simply provide different values in the range 0 to 1. Where zero implies no illumination.

Vertical discretization
-----------------------

The vertical discretization relies on assembling different SPICE unit cells to correctly represent the structure. Internally, each SPICE unit cell is a Python object, these are first assembled into a 3D grid objects and then processed to derive the netlist. These objects are contained in the module,

- Unit Cell Module: :doc:`solcore/spice/model.py <../solcore/spice/model.py>`

We closely follow the model of [#Ref1]_ M. Steiner et al., please review the paper for an understanding how the model functions.

In this document we will discuss how to use the SolCore implementation.

Define a function dictionary for each cell in the structure. For example, a single-junction solar cell can be defined as,
::

    # Define junction parameters with a Python dictionary
    junctions = [
            {
                "jsc": 30000,
                "emitter_sheet_resistance": 100.0,
                "j01": 4e-16,
                "j02": 2e-7,
                "Eg": 1.41,
                "n1": 1.0,
                "n2": 2.0
            }
        ]

The parameters are:

* `jsc`, the short-circuit current generated by the junction in A / m2.
* `emitter_sheet_resistance`, the sheet resistance of the emitter region in Ohm per square.
* `j01`, the saturation current density in the neutral region in A / m2.
* `j02`, the saturation current density in the bulk region in A / m2.
* `Eg`, the bandgap of the material in eV (this one is no SI units!).
* `n1`, the ideality factor of the `j01` diode, default is 1.
* `n2`, the ideality factor of the `j02` diode, default is 2.

Note that shunt resistance is not currently included in this modelling because for concentrator solar cells it is so large as to be negligible, but it could be added.

Generate Netlist
----------------

Use the `generate_netlist` function to process all the inputs discussed so far to a SPICE net list,
::

    # Generate a SPICE netlist from a metal and illumiation images, the solar cell size and the junction information
    netlist = generate_netlist(
        grid,
        illumination_map,
        size,
        junctions,
    )

Netlist generation is highly efficient, no "wires" are needed to connect the unit cells together. Instead, the cells are connected by proper use of net labels. This seems to have improved the solved speed over previous implementations.

Note
====

The base layer and rear contact layers are not modelled as distributed elements. This has been done to follow the implementation of Steiner and also speeds up computation time.

Solve Netlist
-------------

The netlist is solved by stepping the voltage to find the maximum power point,
::

    v_start = -0.1  # the starting voltage of the sweep
    v_stop = 1.5  # the end voltage of the sweep
    v_step = 0.01  # the step size of the sweep
    result = solve_netlist(netlist, temperature, v_start, v_stop, v_step)

The module provides functions that process and plot the `result` object to return useful information. For example, the IV curve,
::

    v, i = get_characterisic_curve(result)
    plot_characteristic_curve(v, i)

The maximum power point,
::

    vmax, pmax, maxidx = get_maximum_power_point(result)
    # vmax = the voltage at the maximum power point
    # pmax = the maximum power
    # maxidx = the index in the IV curve of the maximum power point

Layer voltage can be plotted to show voltage maps,
::

    voltages = get_node_voltages(result)
    voltages.shape  # (120, 120, 3, 161)

Here, `voltages` is a 3 + 1 dimensional array. The first three dimensions correspond to the physical x, y, and z locations in the discretization, and the last dimension corresponds to the number of steps in the voltage sweep.

The first z index is the metal layer, the second z index is the PV (emitter) layer, and the third is the base and buffer layers.

The helper function plots both the metal and PV layer voltages,
::

    plot_surface_voltages(voltages, bias_index=maxidx)

.. image:: Layer_Voltages.png
    :align: center

A generalised Planck estimate of the electroluminescence intensity can be made using,
::

    pv_layer_idx = 1  # index = 1 is the PV layer
    pv_layer_voltages = voltages[:, :, pv_layer_idx, maxidx]
    el = get_electroluminescence(pv_layer_voltages, is_metal=grid.is_metal)
    plot_electroluminescence(el)

Note, some additional information is needed to mask off the metal layers such that the image predicts what might be actually seen.

.. image:: EL_Prediction.png
    :align: center

A Detailed Example
------------------

Let's create a Solcore solar cell model based on the solar cell structure above and get it to calculate the short-circuit current.
::

    from solcore.structure import Junction
    from solcore.solar_cell import SolarCell
    from solcore.solar_cell_solver import solar_cell_solver
    from solcore.light_source import LightSource

    def get_jsc(concentrationX):
        junction_model = Junction(
            kind='2D',
            T=temperature,
            reff=1,
            jref=300,
            Eg=1.4,
            A=1,
            R_sheet_top=100,
            R_sheet_bot=1e-16,
            R_shunt=1e16,
            n=3.5
        )

        solar_cell_model = SolarCell([junction_model], T=temperature)
        wl = np.linspace(350, 2000, 301) * 1e-9
        light_source = LightSource(
            source_type="standard",
            version="AM1.5g",
            x=wl,
            output_units="photon_flux_per_m",
            concentration=concentrationX
        )

        options = {
            "light_iv": True,
            "wavelength": wl,
            "light_source": light_source,
            "optics_method": "BL"
        }
        solar_cell_solver(solar_cell_model, 'iv', user_options=options)

        jsc = solar_cell_model(0).jsc
        return jsc

    # Get the JSC for 100x concentration
    jsc = get_jsc(100)

Create a second function that wraps the SPICE model and returns the device's efficiency. Inside this function, it calls solcore to estimate the JSC using the above `get_jsc` function,
::

    def get_efficiency(concentrationX, power_in=1000.0):
        
        bus_px = 10
        fingers_px =  [4, 4, 4, 4, 4, 4]
        offset_px = 3
        nx, ny = 120, 120
        grid = HGridPattern(bus_px, fingers_px, offset_px=offset_px, nx=nx, ny=ny)

        # Homogeneous illumination
        illumination_map = np.ones(nx * ny).reshape((nx, ny))

        # The size of the solar is 3mm x 3mm
        size = (0.003, 0.003) # meters

        # Define a list of properies that describe each junction in the solar cell.
        # NB: currently only one junction is working.
        junctions = [
            {
                "jsc": get_jsc(concentrationX),  # solcore is calculating this for us!
                "emitter_sheet_resistance": 100.0,
                "j01": 4e-16,
                "j02": 2e-7,
                "Eg": 1.41,
                "n1": 1.0,
                "n2": 2.0
            }
        ]

        temperature = 300.0

        netlist = generate_netlist(
            grid,
            illumination_map,
            size,
            junctions,
            temperature=temperature
        )

        result = solve_netlist(netlist, temperature, 0.0, 1.5, 0.01)

        vmax, pmax, maxidx = get_maximum_power_point(result)
        
        p_per_m2 = pmax / size[0] / size[1]
        efficiency = p_per_m2 / (concentrationX * power_in)
        return efficiency

Finally, let's loop over a few concentration values to see if we can plot a concentration vs. efficiency plot.
::

    effs = list()
    x_values = [1, 10, 100, 200, 500, 1000]
    for x in x_values:
        effs.append(get_efficiency(x))

    plt.semilogx(x_values, 100 * np.array(effs))
    plt.grid(linestyle="dotted")
    plt.xlabel("Concentration")
    plt.ylabel("Efficiency (%)")
    plt.show()


References
----------

.. [#Ref1] M. Steiner et al., "Validated front contact grid simulation for GaAs solar cells under concentrated sunlight", Progress in Photovoltaics, Volume 19, Issue 1, January 2011, Pages 73-83. DOI: 10.1002/pip.989.


Netlist Generation and Solution Functions
-----------------------------------------

.. automodule:: solcore.spice.netlist
    :members:
    :undoc-members:

Result Processing and Plotting Functions
----------------------------------------

.. automodule:: solcore.spice.result
    :members:
    :undoc-members:

Spice Unit Cell Model Objects
-----------------------------

.. automodule:: solcore.spice.model
    :members:
    :undoc-members:

Grid Generation Objects
-----------------------

.. automodule:: solcore.spice.grid
    :members:
    :undoc-members: